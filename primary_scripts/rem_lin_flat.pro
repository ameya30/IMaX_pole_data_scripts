pro rem_lin_flat,infilename,outfilename,use_gaussfit=use_gaussfit

; This program starts from flats produced by
; mk_flat and generates a new set of flats that 
; has no blueshift illumination effect of the spectral 
; line.

; It assumes that the flats have illumination gradients,
; fringes, polarization illumination gradients, and 
; wavelength illumination gradients generated by the
; blueshift of the line over the FOV. It removes only the
; later gradient. It assumes fringes are different for
; each wavelength and for each polarization state.

; It uses 936x936 flats with no frame 

;IDL>rem_lin_flat,'flats_DATA_10_set_l12-2.save','remlin_10_l12-2.save',use_gaussfit=0

; use longitudinal=1 to indicate L12-2 or L3-2 mode

; Input are: flats saveset and housekeeping saveset

; Output are: saveset with flats after removing blueshift, saveset
; with prefilter corrections, polynomial coefficients for wavelengtl cal, 
; text file with printed data and a png file with the blueshift.

; Change housekeeping and output save set names to those you are using !!!!

pathr = '/data/waller/IMaX/imax_pros_011110/sets_index/'
patho = '/data/waller/IMaX/imax_pros_011110/flats_stage4/' 
; output text file  

openw,1,strmid(outfilename,0,strpos(outfilename,'.s'))+'.txt'

; restore data

restore,infilename,/v
ndim=sizeofnew(ff1,1)
print,'Images are of size=',ndim,ndim 
printf,1,'Images are of size=',ndim,ndim 

restore,pathr+'set_12thJune91hr.sav',/v ; housekeeping

dd1=where(numobse1 eq obsen,nobsen1)
print,'Number of observations of Cam1 for this observing sequence=',nobsen1
printf,1,'Number of observations of Cam1 for this observing sequence=',nobsen1
dd2=where(numobse2 eq obsen,nobsen2)
print,'Number of observations of Cam2 for this observing sequence=',nobsen2
printf,1,'Number of observations of Cam2 for this observing sequence=',nobsen2

; range for surface fitting

ranfit=4
smwin=3

print,'Using fit range and smoothing factor of=',ranfit,smwin
printf,1,'Using fit range and smoothing factor of=',ranfit,smwin

; integrates all polarization states

ffl1=total(ff1,4)/float(n_pol)
ffl2=total(ff2,4)/float(n_pol)

; note: ffl1 and ffl2 have the illumination gradients, the fringes for each wavelength
;       the line blueshift but not the polarization gradients. 

; illumination gradients are selected from polarization
; integrated data at continuum wavelengths 
; L12-2 uses 0 and n_lambda-1. Residual effects in L12-2 are due to
; the way in which prefilter is treated. An illumination gradient
; comes from the prefilter being strong in the bluest wavelengths
; of L12-2.

if (n_lambda eq 12) then begin
	 ffi1=reform(ffl1[*,*,0]+ffl1[*,*,n_lambda-1])/2.
	 ffi2=reform(ffl2[*,*,0]+ffl2[*,*,n_lambda-1])/2.
endif else begin
	 ffi1=reform(ffl1[*,*,n_lambda-1])
	 ffi2=reform(ffl2[*,*,n_lambda-1])
endelse

; Some normalization

ffi1=ffi1/mean(ffi1)
ffi2=ffi2/mean(ffi2)

; fit surfaces to ffi flats:

tmp=smooth(ffi1,smwin)
sss=sfit(tmp,ranfit)
ffi1=sss/mean(sss)

tmp=smooth(ffi2,smwin)
sss=sfit(tmp,ranfit)
ffi2=sss/mean(sss)

; remove illumination gradient from lambda flats

for ind=0,n_lambda-1 do ffl1[*,*,ind]=ffl1[*,*,ind]/ffi1[*,*]
for ind=0,n_lambda-1 do ffl2[*,*,ind]=ffl2[*,*,ind]/ffi2[*,*]

; Next stuff removes an extra gradient present in the spectral lines 
; only and inferred from averaging all points inside the line
; to minimize the blueshift 

; We do a different thing for L12-2 that is needed due to
; the prefilter effects being more evident there.

if (n_lambda eq 12) then begin 
	; this removes some prefilter effects
	ffs1l=total(ffl1[*,*,1:2],3)/float(2)
	ffs1r=total(ffl1[*,*,n_lambda-3:n_lambda-2],3)/float(2)
	ffs2l=total(ffl2[*,*,1:2],3)/float(2)
	ffs2r=total(ffl2[*,*,n_lambda-3:n_lambda-2],3)/float(2)
	
	ffs1l=ffl1[*,*,1]
	ffs1r=ffl1[*,*,n_lambda-1]
	ffs2l=ffl2[*,*,1]
	ffs2r=ffl2[*,*,n_lambda-1]
	
	tmp=smooth(ffs1l,smwin)
	sss=sfit(tmp,ranfit)
	ffs1l=sss/mean(sss)

	tmp=smooth(ffs1r,smwin)
	sss=sfit(tmp,ranfit)
	ffs1r=sss/mean(sss)

	tmp=smooth(ffs2l,smwin)
	sss=sfit(tmp,ranfit)
	ffs2l=sss/mean(sss)

	tmp=smooth(ffs2r,smwin)
	sss=sfit(tmp,ranfit)
	ffs2r=sss/mean(sss)

	for ind=0,5 do ffl1[*,*,ind]=ffl1[*,*,ind]/ffs1l[*,*] ; 
	for ind=0,5 do ffl2[*,*,ind]=ffl2[*,*,ind]/ffs2l[*,*] ; 
	ffl1[*,*,6]=ffl1[*,*,6]/((ffs1l[*,*]+ffs1r[*,*])/2.) ; 
	ffl2[*,*,6]=ffl2[*,*,6]/((ffs2l[*,*]+ffs2r[*,*])/2.) ; 
	for ind=7,n_lambda-1 do ffl1[*,*,ind]=ffl1[*,*,ind]/ffs1r[*,*] ; 
	for ind=7,n_lambda-1 do ffl2[*,*,ind]=ffl2[*,*,ind]/ffs2r[*,*] ; 
endif else begin
	ffs1=total(ffl1[*,*,0:n_lambda-2],3)/float(n_lambda-1)
	ffs2=total(ffl2[*,*,0:n_lambda-2],3)/float(n_lambda-1)

	tmp=smooth(ffs1,smwin)
	sss=sfit(tmp,ranfit)
	ffs1=sss/mean(sss)

	tmp=smooth(ffs2,smwin)
	sss=sfit(tmp,ranfit)
	ffs2=sss/mean(sss)

	for ind=0,n_lambda-2 do ffl1[*,*,ind]=ffl1[*,*,ind]/ffs1[*,*] ; 
	for ind=0,n_lambda-2 do ffl2[*,*,ind]=ffl2[*,*,ind]/ffs2[*,*] ; 
endelse

;; find wavelength gradients

; some normalization 

ffl1=ffl1/mean(ffl1) ;
ffl2=ffl2/mean(ffl2)

for ind=0,n_lambda-1 do begin
	tmp=smooth(ffl1[*,*,ind],smwin)
	sss=sfit(tmp,ranfit)
	ffl1[*,*,ind]=sss/mean(sss)
	
	tmp=smooth(ffl2[*,*,ind],smwin)
	sss=sfit(tmp,ranfit)
	ffl2[*,*,ind]=sss/mean(sss)
endfor

norma1=total(total(ff1,1),1)/float(ndim*ndim) 
norma2=total(total(ff2,1),1)/float(ndim*ndim)

print,'Intensities for Cam1=',norma1
print,'Intensities for Cam2=',norma2
printf,1,'Intensities for Cam1=',norma1
printf,1,'Intensities for Cam2=',norma2

; Restore line intensities in ffl array (needed for wavelength cal below).

for ind=0,n_lambda-1 do begin
	ffl1[*,*,ind]=ffl1[*,*,ind]*mean(norma1[ind,*])/mean(norma1[n_lambda-1,*])
	ffl2[*,*,ind]=ffl2[*,*,ind]*mean(norma2[ind,*])/mean(norma2[n_lambda-1,*])
endfor

; Start blueshift cal (wavelength cal). Output are sk coefficients
; of a 2D polynomial of degree 3 that provide wavelength offset
; for each pixel. 0 lambda is quiet sun mean profile center.
; An explanation of how to compute this surface is given below.

; output saveset with prefilter factors

pref_factors = patho + 'pref_factors_' + strmid(outfilename, 0, strpos(outfilename,'.s')) + '.sav'
; nominal wavelength positions

if (n_lambda eq 5) then lll=[-.08,-.04,.04,.08,.227]
if (n_lambda eq 3) then lll=[-.06,.06,.227]
if (n_lambda eq 12) then lll=[-0.1925,-0.1575,-0.1225,-0.0875,-0.0525,-0.0175, $
0.0175,0.0525,0.0875,0.1225,0.1575,0.1925]

; this is IMaX ref spectrum. FTS convolved with IMaX PSF.
; It compares perfectly with that measured at ESRANGE
; (average over only central part of FOV).
restore,'IMaX_Spectrum_fts.save'

dd=where(xl gt 5250.05 and xl lt 5250.4)
result=gaussfit(xl[dd],res[dd],aa,nterms=4)
llo=aa[1] ; cal day lambda
xl=xl-llo

; intensities at nominal lambdas

int_ref=interpol(res,xl,lll)
res=res/int_ref(n_lambda-1)
int_ref=int_ref/int_ref(n_lambda-1)

;extract arrays for later used (bottom of program)

dd=where(xl gt -.5 and xl lt .6)
xl=xl(dd)
xl_samp=mean(deriv(xl))
res=res(dd)

; from jan14 calibration in Lindau. Prefilter curve.

restore,'Prefilter_transmission_jan14_Lindau.save',/v

acf=reform(mean(acoef1[dd1]))
acf=acf[0]
; this is the a value of pointing where observations are made (not the flat!)

print,'a coefficient used in this flat=',acf
printf,1,'a coefficient for this flat=',acf

; this (a_diskc) should be the a that would have been obtained in
; the region where the flat was made (normally disk center...)
; as flats where not always made at the same poistion it changes !!!!
; NEEDS ITERATION AS WE DO NOT KNOW WHERE WE POINTED !!!!

;a_diskc=-0.791d0 ; central meridiam estimation from log book

;a_diskc=-0.771d0 ; central meridiam estimation from log book
		 ; this is good for flat #1 the 13.

;a_diskc=-0.781d0 ; central meridiam estimation from log book
		 ; this is good for flat #2 and #3 the 13.


;a_diskc=acf      ; in case the flat was made where obsservations
                 ; are made, use this
a_diskc = -0.7819217d0 

diffa=a_diskc-acf  ; shift between flats and observations
sintheta=diffa/0.035 ; +/- 35 mA is full limb solar rotation
mu_eq=cos(asin(sintheta))

print,'Equator equivalent mu is (real mu is smaller)=',mu_eq
printf,1,'Equator equivalent mu is (real mu is smaller)=',mu_eq

if diffa lt 0 then begin
	print,'Observations in East side'
	printf,1,'Observations in East side'
endif else begin
	print,'Observations in West side'
	printf,1,'Observations in West side'
endelse

lll=lll+diffa ; these are the wavelengths used in sampling the line
              ; when doing the flat (often near disk center).
print,'Lambda shift between flats (disk center) and observations (some mu)=',diffa
printf,1,'Lambda shift between flats (disk center) and observations (some mu)=',diffa
print,'New wavelength sampling points for flats=',lll
printf,1,'New wavelength sampling points for flats=',lll

; while observations are made at lll with respect
; to local line center, flats are taken at lll+diffa
; West diffa is positive, East diffa is negative

; voltage difference between calday and flight due to different temperatures

print,'Voltage difference with cal day (volts) =',(a_calday-acf)/b_calday
printf,1,'Voltage difference with cal day (volts) =',(a_calday-acf)/b_calday

print,'Voltages for this flat=',(-acf+lll-diffa)/b_calday
printf,1,'Voltages for this flat=',(-acf+lll-diffa)/b_calday

llo=5250.225d0 ; flight day lambda (with velabs correction)
pref=pref/interpol(pref,llpref-llo,lll[n_lambda-1])

pref_fact=interpol(pref,llpref-llo,lll)

print,'Prefilter factors are =',pref_fact
printf,1,'Prefilter factors are =',pref_fact

save,pref_fact,filename=pref_factors
; IMaX data must be divided by these numbers to account for the prefilter (constant over FOV)

for ind=0,n_lambda-1 do begin
	ffl1[*,*,ind]=ffl1[*,*,ind]/pref_fact[ind] ; remove prefilter
	ffl2[*,*,ind]=ffl2[*,*,ind]/pref_fact[ind] ; remove prefilter
endfor

; save it if needed to compare with arrays at the end
; save,ffl1,ffl2,filename=outfilename+'_tmp'
; note ffl arrays have been remove the illumination gradients, the extra gradients,
; the fringes, the prefilter. Thus, all intensity fluctuations are due to the presence of the
; line in the flats. We now fit gaussians to these data.

; Wavelength cal. Initialize arrays

red_fac=8 ; this is to reduce the # of gaussian fits below

nrdim=ndim/red_fac

lmin1=fltarr(nrdim,nrdim) ; wavelength of each pixel (i.e. IMaX wavelength calibration) 
lmin2=fltarr(nrdim,nrdim) ; same for Cam 2
fwhm1=fltarr(nrdim,nrdim) ; fwhm for each pixel
fwhm2=fltarr(nrdim,nrdim) ; same for Cam2
linc1=fltarr(nrdim,nrdim) ; line center intensity for each pixel
linc2=fltarr(nrdim,nrdim) ; same for Cam 2

; reduced arrays

fflr1=rebin(ffl1,nrdim,nrdim,n_lambda)
fflr2=rebin(ffl2,nrdim,nrdim,n_lambda)

for ind=0,nrdim-1 do begin
	for jnd=0,nrdim-1 do begin
		
		fint=reform(fflr1[ind,jnd,*])
		fint=1.-fint/fint[n_lambda-1]
		co=gaussfit(lll[0:n_lambda-2],fint[0:n_lambda-2],aa,nterms=3)
		lmin1[ind,jnd]=aa[1]
		fwhm1[ind,jnd]=aa[2]*2.*SQRT(2.*ALOG(2.))
		linc1[ind,jnd]=1.-aa[0]
		
		fint=reform(fflr2[ind,jnd,*])
		fint=1.-fint/fint[n_lambda-1]
		co=gaussfit(lll[0:n_lambda-2],fint[0:n_lambda-2],aa,nterms=3)
		lmin2[ind,jnd]=aa[1]
		fwhm2[ind,jnd]=aa[2]*2.*SQRT(2.*ALOG(2.))
		linc2[ind,jnd]=1.-aa[0]

	endfor
endfor

; gaussian fit is not 100 % robuts and creates spikes
; filtering them with a median filter

lmin1=median(lmin1,3) 
lmin2=median(lmin2,3)
fwhm1=median(fwhm1,3)
fwhm2=median(fwhm2,3)
linc1=median(linc1,3)
linc2=median(linc2,3)

print,'FWHM of Fe I 5250.2 over flat FOV and rms for Cam1 (mA)=',mean(fwhm1),stdev(fwhm1)
print,'FWHM of Fe I 5250.2 over flat FOV and rms for Cam2 (mA)=',mean(fwhm2),stdev(fwhm2)
print,'Line center of Fe I 5250.2 over flat FOV and rms for Cam1=',mean(linc1),stdev(linc1)
print,'Line center of Fe I 5250.2 over flat FOV and rms for Cam2=',mean(linc2),stdev(linc2)
printf,1,'FWHM of Fe I 5250.2 over flat FOV and rms for Cam1 (mA)=',mean(fwhm1),stdev(fwhm1)
printf,1,'FWHM of Fe I 5250.2 over flat FOV and rms for Cam2 (mA)=',mean(fwhm2),stdev(fwhm2)
printf,1,'Line center of Fe I 5250.2 over flat FOV and rms for Cam1=',mean(linc1),stdev(linc1)
printf,1,'Line center of Fe I 5250.2 over flat FOV and rms for Cam2=',mean(linc2),stdev(linc2)

; bring wavelength center array to original dimension

lmin1=puff(lmin1,red_fac)
lmin2=puff(lmin2,red_fac)

; blueshift is monotonic, so do a lsqfit to a polynomial degree 3

lm1=sfit(lmin1,3,kx=sk1)
lm2=sfit(lmin2,3,kx=sk2)

; shift camera 2 to camera 1 from pinhole data

shiftpl=fix(round([5.3,-8.2])) ; from pinholes 
lmins2=shift(lmin2,shiftpl) ; fourier shift introduces noise becauss of lack of apodization

lmin=0.5*(lmin1+lmins2)
lm=sfit(lmin,3,kx=sk) ; final blueshift data
print,'Maximum blueshift at corners (mA)=',max(lm-min(lm)) 
printf,1,'Maximum blueshift at corners (mA)=',max(lm-min(lm)) 
print,'Mean blueshift over FOV (mA) =',mean(lm-min(lm)) 
printf,1,'Mean blueshift over FOV (mA) =',mean(lm-min(lm)) 

ref_index=2.3267510 ;LiNbO3 refractive index
delta=(llo/2.)*(0.44*!pi/(180.*ref_index))^2

print,'Maximum theoretical blueshift (mA)=',delta
printf,1,'Maximum theoretical blueshift (mA)=',delta
close,1

window,0,xsize=600,ysize=600
CONTOUR, LEVEL=[0.0,0.001,0.005,0.01,0.015,0.02,0.025,0.03], C_LABELS=[1,1,1,1,1,1,1,1], $
C_CHARSIZE = 1.25, lm, title='IMaX Blueshift (mA)',xtitle='pixels',ytitle='pixels'
ver,ndim/2
hor,ndim/2
wait,0.5

;
save,sk,sk1,sk2,lmin1,lmin2,lmin,diffa,filename='blueshiftcal_'+ $
strmid(outfilename,0,strpos(outfilename,'.s'))+'.sav'

write_png,'blueshiftcal_'+ $
strmid(outfilename,0,strpos(outfilename,'.s'))+'.png',tvrd(/true)

;NOTE: from sk one recovers lm as follows:
;xr = (findgen(ndim)) # replicate(1,ndim) 
;yr = transpose(xr) 
;lm=sk(0)+sk(1)*yr+sk(2)*yr^2+sk(3)*yr^3+                        $
;sk(4)*xr+sk(5)*xr*yr+sk(6)*xr*yr^2+sk(7)*xr*yr^3+                $
;sk(8)*xr^2+sk(9)*xr^2*yr+sk(10)*xr^2*yr^2+sk(11)*xr^2*yr^3+      $
;sk(12)*xr^3+sk(13)*xr^3*yr+sk(14)*xr^3*yr^2+sk(15)*xr^3*yr^3     


; some nice ploting. Here you check the a_diskc value !!!!
wait,1
;d

lm_m=fltarr(ndim,ndim,n_lambda)
for ind=0,n_lambda-1 do lm_m[*,*,ind]=-lm[*,*]+lll[ind] ; calibrated wavelength of
                                                        ; each pixel for ffl arrays
plot,lm_m[*,*,0],ffl1[*,*,0],psym=3,xrange=[-.3,.3], $
ytitle='Stokes I',title='Flat should show the line. Vertical lines relate to a_diskc',yrange=[0.2,1.2] 
for ind=1,n_lambda-1 do oplot,lm_m[*,*,ind],ffl1[*,*,ind],psym=3
oplot,xl,res
ver,lll,lines=1
ver,0,lines=0
write_png,'flatline_'+ $
strmid(outfilename,0,strpos(outfilename,'.s'))+'.png',tvrd(/true)
print,'Data points clouds should start at the location of the vertical dotted lines'
print,'else, change the a_diskc value !!!!!!!!!!!!!!!'

; For flats NOT made at disk center

if use_gaussfit ne 0 then begin

; build arrays
	print,'Entering non disk-center flat correction (needs time)...'

	xxx=reform(lm_m[*,*,0],ndim*ndim)
	yyy1=reform(ffl1[*,*,0],ndim*ndim)
	yyy2=reform(ffl2[*,*,0],ndim*ndim)

	for ind=1,n_lambda-1 do begin
		xxx=[xxx,reform(lm_m[*,*,ind],ndim*ndim)]
		yyy1=[yyy1,reform(ffl1[*,*,ind],ndim*ndim)]
		yyy2=[yyy2,reform(ffl2[*,*,ind],ndim*ndim)]
	endfor

; sorting arrays

	dd=sort(xxx) 
	xxx=xxx(dd)            
	yyy1=yyy1(dd)
	yyy2=yyy2(dd)             

; fitting gaussians

	co=gaussfit(xxx,yyy1,aa1,nterms=4)              
	co=gaussfit(xxx,yyy2,aa2,nterms=4)       

; generate gaussian

	aa=0.5*(aa1+aa2)       
	resf=aa[3]+aa[0]*exp(-(xl-aa[1])^2/(2.*aa[2]^2))     
	oplot,xl,resf,lines=1

endif

; now make the flats from scratch. This could/should work
; Note, we now return to original ff1 and ff2, at each pixel infer
; the intensity from the wavelength cal and the FTS data and remove it 
; from ff1 and ff2. So ffl is not use !!

; New ffls are generated and writen to tmp2 save. By reading the tmp one
; generated before on can compare them

; Note, this takes a while

print,'Generating final flats (this takes a while)...'

for ind=0,ndim-1 do begin
;	print,ndim-1-ind
	for jnd=0,ndim-1 do begin

		ss1=lm1(ind,jnd)
		res_tmp=fft_shift(res,ss1/xl_samp)           
		int_ref=interpol(res_tmp,xl,lll)
		ffl1[ind,jnd,*]=int_ref[*]
;		ffl1[ind,jnd,*]=ffl1[ind,jnd,*]/int_ref[*]
;		this is to compare the two ffls. See comments below
		for knd=0,n_pol-1 do begin
			ff1[ind,jnd,*,knd]=ff1[ind,jnd,*,knd]/int_ref[*]
		endfor
		
		ss2=lm2(ind,jnd)
		res_tmp=fft_shift(res,ss2/xl_samp)           
		int_ref=interpol(res_tmp,xl,lll)
		ffl2[ind,jnd,*]=int_ref[*]
;		ffl2[ind,jnd,*]=ffl2[ind,jnd,*]/int_ref[*]
;		this is to compare the two ffls. See comments below
		for knd=0,n_pol-1 do begin
			ff2[ind,jnd,*,knd]=ff2[ind,jnd,*,knd]/int_ref[*]
		endfor
	endfor
endfor

; final flat normalization. Flats normalize to 1 all of them. 

norma1=total(total(ff1,1),1)/float(ndim*ndim)
norma2=total(total(ff2,1),1)/float(ndim*ndim)

for ind=0,n_lambda-1 do begin
	for jnd=0,n_pol-1 do begin
		ff1[*,*,ind,jnd]=ff1[*,*,ind,jnd]/norma1[ind,jnd]
		ff2[*,*,ind,jnd]=ff2[*,*,ind,jnd]/norma2[ind,jnd]
	endfor
endfor
print, 'line527'
print, outfilename
print, patho+outfilename
save,ff1,ff2,n_lambda,n_pol,n_accum,filename= patho + outfilename
;save,ffl1,ffl2,filename=outfilename+'_ffl' ; this is not use 
                                           ; output is just for checking

end

